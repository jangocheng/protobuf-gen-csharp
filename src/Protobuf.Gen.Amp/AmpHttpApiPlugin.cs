using System;
using System.Collections.Generic;
using System.Text;
using Google.Protobuf.Compiler;
using Google.Protobuf.Reflection;
using Protobuf.Gen.Core;


namespace Protobuf.Gen.Amp
{
    public class AmpHttpApiPlugin : IPlugin
    {     
        public void Process(CodeGeneratorRequest request, CodeGeneratorResponse response)
        {
            if (request.ProtoFile.Count == 0)
            {
                return;
            }
            string ns = "";
            bool genericEnable = false;
            foreach (var protofile in request.ProtoFile)
            {
                protofile.Options.CustomOptions.TryGetBool(DotBPEOptions.GENERIC_HTTPAPIROUTES, out genericEnable);
                if (genericEnable)
                {
                    ns = Utils.GetFileNamespace(protofile);
                    if (string.IsNullOrEmpty(ns))
                    {
                        response.Error = protofile.Name + " don't set namespace";
                        return;
                    }
                    break;
                }
            }
            if (!genericEnable)
            {
                return;
            }


            StringBuilder sb = new StringBuilder();
            sb.AppendLine("// Generated by the protocol buffer compiler.  DO NOT EDIT!");
            sb.AppendLine($"// source: ProtobufObjectfactory");
            //还可以生成注释

            sb.AppendLine("#region Designer generated code");

            sb.AppendLine("");
            sb.AppendLine("using DotBPE.Protobuf;");
            sb.AppendLine("using System.Collections.Generic;");
       
            sb.AppendLine("");

            sb.AppendLine("namespace " + ns + " {");
            //生成代码

            sb.AppendLine("    public static class HttpApiOptions {");

           
            sb.AppendLine("        public static List<HttpApiOption> GetList()");
            sb.AppendLine("        {");

            sb.AppendLine("            var list = new List<HttpApiOption>();");
           

            foreach (var protofile in request.ProtoFile)
            {
                try
                {
                    ProcessByEachFile(protofile,sb);
                }
                catch (Exception ex)
                {
                    response.Error += "file:" + protofile.Name + ":" + ex.Message + ex.StackTrace;
                }
            }
            sb.AppendLine("            return list;");
            sb.AppendLine("        }");
            

            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("#endregion");

            //生成文件
            var nfile = new CodeGeneratorResponse.Types.File
            {
                Name = "HttpApiOptions.cs",
                Content = sb.ToString()
            };
            response.File.Add(nfile);

        }

        private void ProcessByEachFile(FileDescriptorProto protofile,StringBuilder sb)
        {
            bool genericEnable;
            protofile.Options.CustomOptions.TryGetBool(DotBPEOptions.GENERIC_HTTPAPIROUTES, out genericEnable);
            if (!genericEnable)
            {
                return;
            }
            if (protofile.Service == null || protofile.Service.Count <= 0) return;

            foreach (ServiceDescriptorProto service in protofile.Service)
            {
                ProcessEachService(service,sb);
            }
        }

        private void ProcessEachService(ServiceDescriptorProto service, StringBuilder sb)
        {
            int serviceId;
            bool hasServiceId = service.Options.CustomOptions.TryGetInt32(DotBPEOptions.SERVICE_ID, out serviceId);
            if (!hasServiceId || serviceId <= 0)
            {
                throw new Exception("Service=" + service.Name + " ServiceId NOT_FOUND");
            }
            if (serviceId >= ushort.MaxValue)
            {
                throw new Exception("Service=" + service.Name + "ServiceId too large");
            }

         

            foreach (var method in service.Method)
            {
                int msgId;
                bool hasMsgId = method.Options.CustomOptions.TryGetInt32(DotBPEOptions.MESSAGE_ID, out msgId);
                if (!hasMsgId || msgId <= 0)
                {
                    throw new Exception("Service" + service.Name + "." + method.Name + " ' MessageId NOT_FINDOUT ");
                }
                if (msgId >= ushort.MaxValue)
                {
                    throw new Exception("Service" + service.Name + "." + method.Name + " is too large");
                }

                bool hasOption= method.Options.CustomOptions.TryGetMessage<DotBPE.Protobuf.HttpApiOption>(DotBPEOptions.HTTP_API_OPTION, out var options);
                if (hasOption)
                {                   
                    sb.AppendLine("            list.Add(new HttpApiOption()");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                ServiceId = {serviceId},");
                    sb.AppendLine($"                MessageId = {msgId},");
                    sb.AppendLine($"                Path = \"{options.Path}\",");
                    sb.AppendLine($"                Method = \"{options.Method}\",");
                    sb.AppendLine($"                Description = \"{options.Description??""}\"");
                    sb.AppendLine("            });");
                }

            }
        }
    }
}
